{"entries":[{"timestamp":1742793868049,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"H=tDYi9u7)Ge6u./=h/6\" x=\"20\" y=\"20"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start"],[0,"\"></"]],"start1":12,"start2":12,"length1":135,"length2":62},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," id=\"SSAYPq8;Va_,EAGh.[D0\" x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":49,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"/**\n * makecode BMP280 digital pressure and humidity sensor Package.\n * From microbit/micropython Chinese community.\n * http://www.micropython.org.cn\n */\n\nenum BMP280_I2C_ADDRESS {\n    //% block=\"0x76\"\n    ADDR_0x76 = 0x76,\n    //% block=\"0x77\"\n    ADDR_0x77 = 0x77\n}\n\nenum BMP280_T {\n    //% block=\"C\"\n    T_C = 0,\n    //% block=\"F\"\n    T_F = 1\n}\n\nenum BMP280_P {\n    //% block=\"Pa\"\n    Pa = 0,\n    //% block=\"hPa\"\n    hPa = 1\n}\n\n/**\n * BMP280 block\n */\n//% weight=100 color=#70c0f0 icon=\"\\uf042\" block=\"BMP280\"\nnamespace BMP280 {\n    let BMP280_I2C_ADDR = BMP280_I2C_ADDRESS.ADDR_0x76\n\n    function setreg(reg: number, dat: number): void {\n        let buf = pins.createBuffer(2);\n        buf[0] = reg;\n        buf[1] = dat;\n        pins.i2cWriteBuffer(BMP280_I2C_ADDR, buf);\n    }\n\n    function getreg(reg: number): number {\n        pins.i2cWriteNumber(BMP280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BMP280_I2C_ADDR, NumberFormat.UInt8BE);\n    }\n\n    function getInt8LE(reg: number): number {\n        pins.i2cWriteNumber(BMP280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BMP280_I2C_ADDR, NumberFormat.Int8LE);\n    }\n\n    function getUInt16LE(reg: number): number {\n        pins.i2cWriteNumber(BMP280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BMP280_I2C_ADDR, NumberFormat.UInt16LE);\n    }\n\n    function getInt16LE(reg: number): number {\n        pins.i2cWriteNumber(BMP280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BMP280_I2C_ADDR, NumberFormat.Int16LE);\n    }\n\n    let dig_T1 = getUInt16LE(0x88)\n    let dig_T2 = getInt16LE(0x8A)\n    let dig_T3 = getInt16LE(0x8C)\n    let dig_P1 = getUInt16LE(0x8E)\n    let dig_P2 = getInt16LE(0x90)\n    let dig_P3 = getInt16LE(0x92)\n    let dig_P4 = getInt16LE(0x94)\n    let dig_P5 = getInt16LE(0x96)\n    let dig_P6 = getInt16LE(0x98)\n    let dig_P7 = getInt16LE(0x9A)\n    let dig_P8 = getInt16LE(0x9C)\n    let dig_P9 = getInt16LE(0x9E)\n    let dig_H1 = getreg(0xA1)\n    let dig_H2 = getInt16LE(0xE1)\n    let dig_H3 = getreg(0xE3)\n    let a = getreg(0xE5)\n    let dig_H4 = (getreg(0xE4) << 4) + (a % 16)\n    let dig_H5 = (getreg(0xE6) << 4) + (a >> 4)\n    let dig_H6 = getInt8LE(0xE7)\n    setreg(0xF2, 0x04)\n    setreg(0xF4, 0x2F)\n    setreg(0xF5, 0x0C)\n    let T = 0\n    let P = 0\n    let H = 0\n\n    function get(): void {\n        let adc_T = (getreg(0xFA) << 12) + (getreg(0xFB) << 4) + (getreg(0xFC) >> 4)\n        let var1 = (((adc_T >> 3) - (dig_T1 << 1)) * dig_T2) >> 11\n        let var2 = (((((adc_T >> 4) - dig_T1) * ((adc_T >> 4) - dig_T1)) >> 12) * dig_T3) >> 14\n        let t = var1 + var2\n        T = Math.idiv((t * 5 + 128) >> 8, 100)\n        var1 = (t >> 1) - 64000\n        var2 = (((var1 >> 2) * (var1 >> 2)) >> 11) * dig_P6\n        var2 = var2 + ((var1 * dig_P5) << 1)\n        var2 = (var2 >> 2) + (dig_P4 << 16)\n        var1 = (((dig_P3 * ((var1 >> 2) * (var1 >> 2)) >> 13) >> 3) + (((dig_P2) * var1) >> 1)) >> 18\n        var1 = ((32768 + var1) * dig_P1) >> 15\n        if (var1 == 0)\n            return; // avoid exception caused by division by zero\n        let adc_P = (getreg(0xF7) << 12) + (getreg(0xF8) << 4) + (getreg(0xF9) >> 4)\n        let _p = ((1048576 - adc_P) - (var2 >> 12)) * 3125\n        _p = Math.idiv(_p, var1) * 2;\n        var1 = (dig_P9 * (((_p >> 3) * (_p >> 3)) >> 13)) >> 12\n        var2 = (((_p >> 2)) * dig_P8) >> 13\n        P = _p + ((var1 + var2 + dig_P7) >> 4)\n        let adc_H = (getreg(0xFD) << 8) + getreg(0xFE)\n        var1 = t - 76800\n        var2 = (((adc_H << 14) - (dig_H4 << 20) - (dig_H5 * var1)) + 16384) >> 15\n        var1 = var2 * (((((((var1 * dig_H6) >> 10) * (((var1 * dig_H3) >> 11) + 32768)) >> 10) + 2097152) * dig_H2 + 8192) >> 14)\n        var2 = var1 - (((((var1 >> 15) * (var1 >> 15)) >> 7) * dig_H1) >> 4)\n        if (var2 < 0) var2 = 0\n        if (var2 > 419430400) var2 = 419430400\n        H = (var2 >> 12) >> 10\n    }\n\n    /**\n     * get pressure\n     */\n    //% blockId=\"BMP280_GET_PRESSURE\" block=\"pressure %u\"\n    //% weight=80 blockGap=8\n    export function pressure(u: BMP280_P): number {\n        get();\n        if (u == BMP280_P.Pa) return P;\n        else return Math.idiv(P, 100)\n    }\n\n    /**\n     * get temperature\n     */\n    //% blockId=\"BMP280_GET_TEMPERATURE\" block=\"temperature %u\"\n    //% weight=80 blockGap=8\n    export function temperature(u: BMP280_T): number {\n        get();\n        if (u == BMP280_T.T_C) return T;\n        else return 32 + Math.idiv(T * 9, 5)\n    }\n\n    /**\n     * get humidity\n     */\n    //% blockId=\"BMP280_GET_HUMIDITY\" block=\"humidity\"\n    //% weight=80 blockGap=8\n    export function humidity(): number {\n        get();\n        return H;\n    }\n\n    /**\n     * power on\n     */\n    //% blockId=\"BMP280_POWER_ON\" block=\"Power On\"\n    //% weight=22 blockGap=8\n    export function PowerOn() {\n        setreg(0xF4, 0x2F)\n    }\n\n    /**\n     * power off\n     */\n    //% blockId=\"BMP280_POWER_OFF\" block=\"Power Off\"\n    //% weight=21 blockGap=8\n    export function PowerOff() {\n        setreg(0xF4, 0)\n    }\n\n    /**\n     * Calculate Dewpoint\n     */\n    //% block=\"Dewpoint\"\n    //% weight=60 blockGap=8\n    export function Dewpoint(): number {\n        get();\n        return T - Math.idiv(100 - H, 5)\n    }\n\n    /**\n     * Pressure below Event\n     */\n    //% block=\"Pressure below than %dat\" dat.defl=100000\n    export function PressureBelowThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (P < dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * Pressure higher Event\n     */\n    //% block=\"Pressure higher than %dat\" dat.defl=100000\n    export function PressureHigherThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (P > dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * humidity below Event\n     */\n    //% block=\"Humidity below than %dat\" dat.defl=10\n    export function HumidityBelowThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (H < dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * humidity higher Event\n     */\n    //% block=\"Humidity higher than %dat\" dat.defl=50\n    export function HumidityHigherThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (H > dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * temperature below Event\n     */\n    //% block=\"Temperature below than %dat\" dat.defl=10\n    export function TemperatureBelowThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (T < dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * temperature higher Event\n     */\n    //% block=\"Temperature higher than %dat\" dat.defl=30\n    export function TemperatureHigherThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (T > dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * set I2C address\n     */\n    //% blockId=\"BMP280_SET_ADDRESS\" block=\"set address %addr\"\n    //% weight=20 blockGap=8\n    export function Address(addr: BMP280_I2C_ADDRESS) {\n        BMP280_I2C_ADDR = addr\n    }\n}  "],[1,"\n"]],"start1":0,"start2":0,"length1":7983,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":234,"start2":234,"length1":76,"length2":31}]},{"type":"added","filename":"test.ts","value":"// テストはここに来ます。このパッケージが拡張機能として使用されるときにはコンパイルされません。\n"}]}],"snapshots":[{"timestamp":1742793868048,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"BMP280Beta\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1742794407291}